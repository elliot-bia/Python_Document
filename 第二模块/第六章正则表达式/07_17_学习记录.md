# 00 前言
继续学习, 昨天学习了正则表达式, 现在继续学习分组匹配

# 01 知识点1: ()和分组匹配的关系
函数`findall`用来查找匹配的对象  
函数`split`用来划分匹配对象前后的字符,  
但是如果加了`()`在正则表达式里, 即在`findall`里没问题, `split`就会出现带上了正则表达式对象

# 02 知识点2: ip地址的正则表达式
错误版本: `(\d{1,3}\.){3}\d{1,3}` 
正确版本: `(2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`  
比较难的地方应该是`[01]?\d\d?`这里是指0-199的范围, 可以有0 1, 但是一定要有一个数, 最后一个可以没有, 这样就包含了 `0`, `1`, `2-9`, `10`, `10-99`, `100`, 和`101-199`的范围了

# 03 知识点3: `re.X`

```
re_ip = re.compile(r"""
    ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)  # ip的第一组数字, 包含了200-249, 250-255, 0-199的数字
    {3}                                # 可以有三个
    (2[0-4]\d|25[0-5]|[01]?\d\d?)      # 最后一组
    """, re.X)                         # 正则表达式, 可以进行换行, 加注释
match = re_ip.match('192.168.1.1')
print(match.group())
```

# 04 知识点4: 贪婪匹配
贪心匹配跟`?`有关,  即加了问号就尽量少的匹配

如
```
# 只匹配双引号中的内容(包括引号)
import re
re_quote1 = re.compile(r'"(.*)"')
re_quote2 = re.compile(r'"(.*?)"')
text1 = 'Computer says "no. ad"'
text2 = 'Computer says "no. ad", and phose "saye. eya". '

find1 = re_quote.findall(text1)
find2 = re_quote.findall(text2)
find3 = re_quote2.findall(text2)

print(find1)
print(find2)
```

# 05 知识点5: 替换
